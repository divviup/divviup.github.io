---
sidebar_position: 2
---

# How it Works

Learn the high-level workings of Divvi Up and how it accomplishes the
privacy-preserving property.

## Breakdown

Divvi Up functionality can be broadly broken down into several steps.

See the [Distributed Aggregation Protocol (DAP)][DAP] for a highly detailed
specification of the protocol that underpins Divvi Up.

<!-- TODO(inahga): Consider making this a more detailed `mermaid` diagram -->

![](../static/how-it-works.png#gh-dark-mode-only)
![](../static/how-it-works-light.jpg#gh-light-mode-only)

### Step 0: Subscriber sets up Divvi Up

Subscribers are entities, such as app developers, who wish to collect quantifiable metrics
about their end-user applications.

The subscriber chooses a Distributed Aggregation Protocol (DAP) client library, which is used for interacting with any DAP-compatible metrics aggregators, such as the ones provided by Divvi Up and its partners.
A client library for [Rust (janus_client)][janus_client] and [TypeScript (divviup-ts)][divviup-ts] is available.

For each metric, the subscriber creates a task, whose parameters encode data about the measurement being taken.

### Step 1: Client generates measurements

The subscriber writes and deploys app functionality that takes measurements corresponding to each task.
Using a DAP client library, they also encode some of the task parameters into the app, such as the task identifier, measurement type, and the Divvi Up aggregators being used.

For each measurement, the subsequent steps are performed.

### Step 2: Client shards the measurement

With the client library, the app randomly shards the measurement into two shares, known
as report shares. One report share is for a leader aggregator, and the other for a
helper aggregator.

Both aggregators advertise a public key and possess its corresponding private key.
The client library encrypts each share with the respective aggregator's public key.

### Step 3: Client sends shares to the aggregators

The client library sends each report share via HTTPS to the leader and helper
aggregator.

Aggregators reject out-of-range or invalid measurements, as defined in the task parameters. This is done without knowledge of the full input measurement.

The aggregators in use are determined by the app developer and encoded in the
task parameters. Each aggregator is operated independently by two different
organizations. Often, Divvi Up will act as the leader, while another
organization operates as a helper.

<!-- TODO(#11): link BYOH guide here -->

Crucially, these organizations are non-colluding. They do not directly share
report shares or otherwise conspire to defeat the protocol. If you do not trust
any of the already-available third-party organizations that Divvi Up partners
with, you can self-host your own helper aggregator.

:::note
Both shares are actually sent to the leader aggregator. The leader
aggregator relays the helper's report share to the helper. Because the helper's
report share is encrypted to the helper, the leader cannot read it and the
non-collusion property is preserved.

This is done to simplify client library implementation and reduce the number of
client network round-trips.
:::

### Step 4: Aggregators perform aggregation

The aggregators use [multi-party computation][MPC] to work together to compute
an aggregate across a batch of report shares, without revealing the report share
to each other and without having any knowledge of the actual submitted
measurement.

The protocol and cryptography involved is described in [Verifiable Distributed
Aggregation Functions (VDAF)][VDAF].

Computation will yield two aggregate shares, one for each aggregator.

### Step 5: Subscriber collects aggregate metrics

The subscriber operates a collector, which queries each aggregator to collect
the aggregate shares. Depending on the query type, this could be a query over a
time interval, or for an arbitrary batch of reports.

Aggregates often aren't available immediately, depending on the query type. The
collector will poll the aggregator until it's ready.

Each aggregate share is encrypted to the collector. The collector reconstitutes
the aggregate shares, yielding the aggregate result and the number of reports
included in the result.

<!--
TODO(https://github.com/divviup/janus-ops/issues/1005): we should make mention of the adapters we
come up with here.
-->

Off-the-shelf collectors that more elegantly handle the collection process and
presentation of data are currently in development.

:::note
Similar to with report shares, a collector does not directly talk to
both aggregators. Instead the helper's aggregate share is relayed through the
leader. Because each share is encrypted to the collector, the leader cannot read
the aggregate shares or reconstitute the aggregate.
:::

[DAP]: https://datatracker.ietf.org/doc/draft-ietf-ppm-dap/ 
[MPC]: https://en.wikipedia.org/wiki/Secure_multi-party_computation
[VDAF]: https://datatracker.ietf.org/doc/draft-irtf-cfrg-vdaf/
[divviup-ts]: https://github.com/divviup/divviup-ts
[janus_client]: https://crates.io/crates/janus_client 